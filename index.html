<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planta Automatizada - Brazo Rob√≥tico 3DOF</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Configuraci√≥n de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 30, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);
        camera.lookAt(0, 3, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Iluminaci√≥n
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(15, 20, 15);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 60;
        mainLight.shadow.camera.left = -30;
        mainLight.shadow.camera.right = 30;
        mainLight.shadow.camera.top = 30;
        mainLight.shadow.camera.bottom = -30;
        scene.add(mainLight);
        
        const fillLight = new THREE.PointLight(0x4a90e2, 0.8);
        fillLight.position.set(-10, 8, -10);
        scene.add(fillLight);
        
        const accentLight = new THREE.PointLight(0xff9500, 0.6);
        accentLight.position.set(10, 5, 10);
        scene.add(accentLight);
        
        // Piso
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a,
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grid
        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);
        
        // ============================================
        // CONFIGURACI√ìN DEL MODELO GLB
        // ============================================
        const ROBOT_CONFIG = {
            url: 'https://raw.githubusercontent.com/juanrios27/robot/main/Ensamble_Completo_de_dise%C3%B1o.glb',
            scale: 10,
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: -90, y: 0, z: 0 }
        };
        
        let robotGroup = new THREE.Group();
        let baseRotation, link1Group, link2Group, gripperBase;
        let robotLoaded = false;
        
        // Cargar modelo GLB desde URL
        function loadRobotGLB() {
            const loader = new THREE.GLTFLoader();
            
            console.log('üì¶ Cargando modelo GLB desde:', ROBOT_CONFIG.url);
            
            loader.load(
                ROBOT_CONFIG.url,
                function(gltf) {
                    console.log('‚úÖ Modelo GLB cargado exitosamente');
                    
                    const model = gltf.scene;
                    
                    model.scale.set(ROBOT_CONFIG.scale, ROBOT_CONFIG.scale, ROBOT_CONFIG.scale);
                    model.position.set(ROBOT_CONFIG.position.x, ROBOT_CONFIG.position.y, ROBOT_CONFIG.position.z);
                    model.rotation.set(
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.x),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.y),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.z)
                    );
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    robotGroup.add(model);
                    
                    baseRotation = model.getObjectByName('Base') || model.getObjectByName('base') || robotGroup;
                    link1Group = model.getObjectByName('Link1') || model.getObjectByName('Hombro') || robotGroup;
                    link2Group = model.getObjectByName('Link2') || model.getObjectByName('Codo') || robotGroup;
                    gripperBase = model.getObjectByName('Gripper') || model.getObjectByName('EndEffector') || robotGroup;
                    
                    scene.add(robotGroup);
                    robotLoaded = true;
                    
                    console.log('ü§ñ Robot integrado en la escena');
                },
                function(xhr) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    console.log('‚è≥ Cargando: ' + percent + '%');
                },
                function(error) {
                    console.error('‚ùå Error al cargar el modelo GLB:', error);
                    console.log('‚ö†Ô∏è Verifica que la URL sea correcta y el archivo sea accesible');
                }
            );
        }
        
        loadRobotGLB();
        
        // BANDA TRANSPORTADORA
        const conveyorGroup = new THREE.Group();
        
        const conveyorBase = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.6, 3.5),
            new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                roughness: 0.7,
                metalness: 0.3
            })
        );
        conveyorBase.position.y = 0.3;
        conveyorBase.castShadow = true;
        conveyorBase.receiveShadow = true;
        conveyorGroup.add(conveyorBase);
        
        const beltSurface = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.1, 3),
            new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.9
            })
        );
        beltSurface.position.y = 0.65;
        conveyorGroup.add(beltSurface);
        
        // Bordes
        const edgeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.5 });
        
        const edge1 = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.5, 0.2),
            edgeMat
        );
        edge1.position.set(0, 0.65, 1.6);
        conveyorGroup.add(edge1);
        
        const edge2 = edge1.clone();
        edge2.position.z = -1.6;
        conveyorGroup.add(edge2);
        
        conveyorGroup.position.set(-9, 0, 0);
        scene.add(conveyorGroup);
        
        // ESTACI√ìN DE INSPECCI√ìN
        const inspectionStation = new THREE.Group();
        
        const stationBase = new THREE.Mesh(
            new THREE.BoxGeometry(3.5, 1.8, 3.5),
            new THREE.MeshStandardMaterial({ 
                color: 0x27ae60,
                roughness: 0.5,
                metalness: 0.4,
                emissive: 0x27ae60,
                emissiveIntensity: 0.1
            })
        );
        stationBase.position.y = 0.9;
        stationBase.castShadow = true;
        inspectionStation.add(stationBase);
        
        const stationPanel = new THREE.Mesh(
            new THREE.BoxGeometry(3, 2.5, 0.2),
            new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.2,
                metalness: 0.8
            })
        );
        stationPanel.position.set(0, 2.5, 1.8);
        inspectionStation.add(stationPanel);
        
        const indicators = [];
        for (let i = 0; i < 3; i++) {
            const indicator = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 2, 32),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.8
                })
            );
            indicator.position.set(-0.8 + i * 0.8, 2.8, 1.5);
            inspectionStation.add(indicator);
            indicators.push(indicator);
            
            const light = new THREE.PointLight(0x00ffff, 0.5, 6);
            light.position.copy(indicator.position);
            inspectionStation.add(light);
        }
        
        inspectionStation.position.set(8, 0, 0);
        scene.add(inspectionStation);
        
        // SISTEMA DE PIEZAS
        const pieces = [];
        const pieceMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff9500,
            roughness: 0.4,
            metalness: 0.6,
            emissive: 0xff9500,
            emissiveIntensity: 0.2
        });
        
        function createPiece() {
            const piece = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                pieceMaterial
            );
            piece.position.set(-15, 1, 0);
            piece.castShadow = true;
            piece.receiveShadow = true;
            scene.add(piece);
            pieces.push({
                mesh: piece,
                state: 'onConveyor',
                pickedUp: false
            });
        }
        
        // Variables de animaci√≥n
        let baseAngle = 0;
        let shoulderAngle = 0;
        let elbowAngle = 0;
        
        let pieceInGripper = null;
        let animationPhase = 0;
        let phaseStartTime = Date.now();
        
        const phaseDurations = [100, 1800, 1200, 1200, 2200, 1600, 1000, 1500];
        
        function smoothAngle(current, target, speed) {
            const diff = target - current;
            if (Math.abs(diff) < 0.5) return target;
            return current + diff * speed;
        }
        
        let lastPieceTime = Date.now();
        let singlePieceCreated = false;
        
        // Control de orientaci√≥n del dispositivo
        let alpha = 0, beta = 0, gamma = 0;
        
        // Detectar orientaci√≥n del dispositivo
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function(event) {
                alpha = event.alpha || 0;
                beta = event.beta || 0;
                gamma = event.gamma || 0;
            });
        }
        
        // Control t√°ctil para dispositivos sin giroscopio
        let touchStartX = 0, touchStartY = 0;
        let cameraRotationY = 0, cameraRotationX = 0;
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            cameraRotationY += deltaX * 0.005;
            cameraRotationX += deltaY * 0.005;
            
            cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            
            // Generar solo UNA pieza al inicio
            if (!singlePieceCreated && pieces.length === 0) {
                createPiece();
                singlePieceCreated = true;
            }
            
            // Mover piezas en banda
            pieces.forEach(p => {
                if (p.state === 'onConveyor') {
                    p.mesh.position.x += 0.035;
                    p.mesh.rotation.y += 0.02;
                }
            });
            
            // Control de fases - esperar hasta que la caja est√© en posici√≥n
            const phaseElapsed = now - phaseStartTime;
            
            // Verificar si hay pieza en la zona de recogida
            let pieceInPickupZone = false;
            let targetPiece = null;
            for (let p of pieces) {
                if (p.state === 'onConveyor' && p.mesh.position.x >= -8.5 && p.mesh.position.x <= -7.8) {
                    pieceInPickupZone = true;
                    targetPiece = p;
                    break;
                }
            }
            
            // L√≥gica de avance de fases
            let canAdvance = false;
            
            if (animationPhase === 0) {
                // Case 0: Esperar muy poco tiempo, solo para detectar la pieza
                canAdvance = phaseElapsed >= phaseDurations[0];
                if (canAdvance && !pieceInGripper && targetPiece) {
                    pieceInGripper = targetPiece;
                }
            } else if (animationPhase === 1) {
                // Case 1: Esperar a que la pieza llegue a la zona de recogida
                if (pieceInPickupZone && pieceInGripper) {
                    canAdvance = phaseElapsed >= phaseDurations[1];
                } else if (!pieceInGripper && targetPiece) {
                    // Si detectamos una pieza nueva, asignarla
                    pieceInGripper = targetPiece;
                }
                // Si no hay pieza en zona, esperamos indefinidamente
            } else {
                // Resto de fases: avanzar normalmente
                canAdvance = phaseElapsed >= phaseDurations[animationPhase];
            }
            
            if (canAdvance) {
                animationPhase = (animationPhase + 1) % 8;
                phaseStartTime = now;
                
                // Al completar el ciclo, eliminar pieza y preparar para crear nueva
                if (animationPhase === 0 && pieceInGripper) {
                    if (pieceInGripper.state === 'delivered') {
                        scene.remove(pieceInGripper.mesh);
                        const idx = pieces.indexOf(pieceInGripper);
                        if (idx > -1) pieces.splice(idx, 1);
                        
                        singlePieceCreated = false;
                    }
                    pieceInGripper = null;
                }
            }
            
            // Definir targets seg√∫n fase
            let targetBase = 0, targetShoulder = 0, targetElbow = 0;
            
            switch(animationPhase) {
                case 0: // Posici√≥n inicial - espera muy breve
                    targetBase = 0;
                    targetShoulder = 0;
                    targetElbow = 0;
                    break;
                case 1: // Aproximarse - SE QUEDA AQU√ç hasta que la caja llegue
                    targetBase = -55;
                    targetShoulder = 0;
                    targetElbow = 0;
                    break;
                case 2: // Recoger - LA CAJA YA EST√Å EN POSICI√ìN
                    targetBase = 130;
                    targetShoulder = 0;
                    targetElbow = 0;
                    if (pieceInGripper && !pieceInGripper.pickedUp) {
                        pieceInGripper.state = 'picked';
                        pieceInGripper.pickedUp = true;
                    }
                    break;
                case 3:
                    targetBase = 0;
                    targetShoulder = 35;
                    targetElbow = 0;
                    break;
                case 4:
                    targetBase = 180;
                    targetShoulder = 0;
                    targetElbow = 0;
                    break;
                case 5:
                    targetBase = 75;
                    targetShoulder = 60;
                    targetElbow = 95;
                    break;
                case 6:
                    targetBase = 75;
                    targetShoulder = 65;
                    targetElbow = 105;
                    if (pieceInGripper && pieceInGripper.state === 'picked') {
                        scene.remove(pieceInGripper.mesh);
                        pieceInGripper.state = 'delivered';
                    }
                    break;
                case 7:
                    targetBase = 0;
                    targetShoulder = 20;
                    targetElbow = 40;
                    break;
            }
            
            // Aplicar movimiento suave
            baseAngle = smoothAngle(baseAngle, targetBase, 0.09);
            shoulderAngle = smoothAngle(shoulderAngle, targetShoulder, 0.09);
            elbowAngle = smoothAngle(elbowAngle, targetElbow, 0.09);
            
            // Aplicar rotaciones solo si los grupos existen
            if (baseRotation && baseRotation.rotation) {
                baseRotation.rotation.y = THREE.MathUtils.degToRad(baseAngle);
            }
            if (link1Group && link1Group.rotation) {
                link1Group.rotation.z = THREE.MathUtils.degToRad(shoulderAngle);
            }
            if (link2Group && link2Group.rotation) {
                link2Group.rotation.z = THREE.MathUtils.degToRad(elbowAngle);
            }
            
            // Actualizar posici√≥n de pieza en gripper
            if (pieceInGripper && pieceInGripper.state === 'picked' && gripperBase && gripperBase.getWorldPosition) {
                const gripperPos = new THREE.Vector3();
                gripperBase.getWorldPosition(gripperPos);
                pieceInGripper.mesh.position.copy(gripperPos);
                pieceInGripper.mesh.position.y -= 1.2;
            }
            
            // Limpiar piezas fuera de la banda (solo si no est√°n siendo recogidas)
            for (let i = pieces.length - 1; i >= 0; i--) {
                if (pieces[i].mesh.position.x > 20 && pieces[i].state === 'onConveyor' && pieces[i] !== pieceInGripper) {
                    scene.remove(pieces[i].mesh);
                    pieces.splice(i, 1);
                }
            }
            
            // Animaci√≥n de luces
            indicators.forEach((ind, i) => {
                ind.material.emissiveIntensity = 0.5 + Math.sin(now * 0.003 + i) * 0.4;
            });
            
            // Actualizar c√°mara seg√∫n orientaci√≥n del dispositivo
            const radius = 16;
            const height = 10;
            
            if (alpha !== 0 || beta !== 0 || gamma !== 0) {
                const angleY = THREE.MathUtils.degToRad(alpha);
                const angleX = THREE.MathUtils.degToRad(beta - 90) * 0.3;
                
                camera.position.x = Math.sin(angleY) * radius;
                camera.position.z = Math.cos(angleY) * radius;
                camera.position.y = height + angleX * 5;
            } else {
                camera.position.x = Math.sin(cameraRotationY) * radius;
                camera.position.z = Math.cos(cameraRotationY) * radius;
                camera.position.y = height + Math.sin(cameraRotationX) * 8;
            }
            
            camera.lookAt(0, 3, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
