<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planta Automatizada - 3 L√≠neas de Producci√≥n</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Configuraci√≥n de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 40, 120);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 18, 25);
        camera.lookAt(0, 3, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Iluminaci√≥n
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(15, 25, 15);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 80;
        mainLight.shadow.camera.left = -40;
        mainLight.shadow.camera.right = 40;
        mainLight.shadow.camera.top = 40;
        mainLight.shadow.camera.bottom = -40;
        scene.add(mainLight);
        
        // Piso
        const floorGeometry = new THREE.PlaneGeometry(80, 60);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a,
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grid
        const gridHelper = new THREE.GridHelper(80, 80, 0x333333, 0x222222);
        scene.add(gridHelper);
        
        // CONFIGURACI√ìN DE LAS 3 L√çNEAS DE PRODUCCI√ìN
        const productionLines = [
            {
                id: 0,
                name: 'L√≠nea Cubo',
                zOffset: -12,
                pieceType: 'cube',
                color: 0xff9500,
                geometry: null,
                label: 'üüß'
            },
            {
                id: 1,
                name: 'L√≠nea C√≠rculo',
                zOffset: 0,
                pieceType: 'cylinder',
                color: 0x00ff00,
                geometry: null,
                label: 'üü¢'
            },
            {
                id: 2,
                name: 'L√≠nea Tri√°ngulo',
                zOffset: 12,
                pieceType: 'triangle',
                color: 0xff0000,
                geometry: null,
                label: 'üî∫'
            }
        ];
        
        // Crear geometr√≠as
        productionLines[0].geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        productionLines[1].geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 32);
        productionLines[2].geometry = new THREE.ConeGeometry(0.5, 0.8, 3);
        
        // FUNCI√ìN PARA CREAR BANDA TRANSPORTADORA
        function createConveyor(zOffset) {
            const conveyorGroup = new THREE.Group();
            
            const conveyorBase = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.6, 3.5),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2c3e50,
                    roughness: 0.7,
                    metalness: 0.3
                })
            );
            conveyorBase.position.y = 0.3;
            conveyorBase.castShadow = true;
            conveyorBase.receiveShadow = true;
            conveyorGroup.add(conveyorBase);
            
            const beltSurface = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.1, 3),
                new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.9
                })
            );
            beltSurface.position.y = 0.65;
            conveyorGroup.add(beltSurface);
            
            const edgeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.5 });
            
            const edge1 = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.5, 0.2),
                edgeMat
            );
            edge1.position.set(0, 0.65, 1.6);
            conveyorGroup.add(edge1);
            
            const edge2 = edge1.clone();
            edge2.position.z = -1.6;
            conveyorGroup.add(edge2);
            
            conveyorGroup.position.set(-9, 0, zOffset);
            scene.add(conveyorGroup);
            
            return conveyorGroup;
        }
        
        // FUNCI√ìN PARA CREAR ESTACI√ìN DE INSPECCI√ìN
        function createInspectionStation(zOffset, color) {
            const inspectionStation = new THREE.Group();
            
            const stationBase = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 0.5, 3.5),
                new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.5,
                    metalness: 0.4,
                    emissive: color,
                    emissiveIntensity: 0.1
                })
            );
            stationBase.position.y = 0.9;
            stationBase.castShadow = true;
            inspectionStation.add(stationBase);
            
            const stationPanel = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2.5, 0.2),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.2,
                    metalness: 0.8
                })
            );
            stationPanel.position.set(0, 2.5, 1.8);
            inspectionStation.add(stationPanel);
            
            const indicators = [];
            for (let i = 0; i < 3; i++) {
                const indicator = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 2, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.8
                    })
                );
                indicator.position.set(-0.8 + i * 0.8, 2.8, 1.5);
                inspectionStation.add(indicator);
                indicators.push(indicator);
                
                const light = new THREE.PointLight(0x00ffff, 0.5, 6);
                light.position.copy(indicator.position);
                inspectionStation.add(light);
            }
            
            inspectionStation.position.set(4, -0.5, zOffset);
            scene.add(inspectionStation);
            
            return { station: inspectionStation, indicators };
        }
        
        // FUNCI√ìN PARA CARGAR ROBOT GLB - CADA UNO INDEPENDIENTE
        function loadRobotGLB(zOffset, lineId, robotData) {
            const ROBOT_CONFIG = {
                url: 'https://raw.githubusercontent.com/juanrios27/robot/main/Ensamble_Completo_de_dise%C3%B1o.glb',
                scale: 10,
                position: { x: 0, y: 0, z: zOffset },
                rotation: { x: -90, y: 0, z: 0 }
            };
            
            const loader = new THREE.GLTFLoader();
            
            console.log(`üì¶ Cargando robot ${lineId} en Z=${zOffset}`);
            
            loader.load(
                ROBOT_CONFIG.url,
                function(gltf) {
                    // Crear un grupo completamente NUEVO para este robot
                    const robotGroup = new THREE.Group();
                    
                    // CLONAR el modelo para que sea independiente
                    const model = gltf.scene.clone(true);
                    
                    model.scale.set(ROBOT_CONFIG.scale, ROBOT_CONFIG.scale, ROBOT_CONFIG.scale);
                    model.position.set(0, 0, 0); // Posici√≥n relativa al grupo
                    model.rotation.set(
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.x),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.y),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.z)
                    );
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    robotGroup.add(model);
                    
                    // Posicionar el GRUPO en el mundo
                    robotGroup.position.set(0, 0, zOffset);
                    scene.add(robotGroup);
                    
                    // Guardar referencias INDEPENDIENTES para este robot
                    robotData.group = robotGroup;
                    robotData.model = model;
                    robotData.baseRotation = model.getObjectByName('Base') || model;
                    robotData.link1Group = model.getObjectByName('Link1') || model;
                    robotData.link2Group = model.getObjectByName('Link2') || model;
                    robotData.loaded = true;
                    
                    console.log(`‚úÖ Robot ${lineId} cargado independientemente en Z=${zOffset}`);
                },
                undefined,
                function(error) {
                    console.error(`‚ùå Error cargando robot ${lineId}:`, error);
                }
            );
        }
        
        // CREAR LAS 3 L√çNEAS DE PRODUCCI√ìN
        const conveyors = [];
        const inspectionStations = [];
        const robots = [];
        const pieces = [[], [], []];
        
        productionLines.forEach((line, index) => {
            // Crear banda
            conveyors.push(createConveyor(line.zOffset));
            
            // Crear estaci√≥n de inspecci√≥n
            inspectionStations.push(createInspectionStation(line.zOffset, line.color));
            
            // Inicializar robot con variables COMPLETAMENTE INDEPENDIENTES
            const robotData = {
                id: index,
                zOffset: line.zOffset,
                group: null,
                model: null,
                baseRotation: null,
                link1Group: null,
                link2Group: null,
                loaded: false,
                // Variables de animaci√≥n PROPIAS
                baseAngle: 0,
                shoulderAngle: 0,
                elbowAngle: 0,
                targetBaseAngle: 0,
                targetShoulderAngle: 0,
                targetElbowAngle: 0,
                // Variables de control PROPIAS
                pieceInGripper: null,
                animationPhase: 0,
                phaseStartTime: Date.now() + (index * 500), // Desfase inicial
                currentMovementIndex: 0,
                movementStartTime: 0,
                movementStartPos: { x: 0, y: 0, z: 0 },
                sequenceInitialized: false,
                disappearTime: 0,
                canCreatePiece: true
            };
            
            robots.push(robotData);
            
            // Cargar modelo GLB de forma independiente
            loadRobotGLB(line.zOffset, index, robotData);
        });
        
        // SECUENCIA DE MOVIMIENTOS (se ajusta para cada l√≠nea con su Z)
        const movementSequence = [
            { x: -4, y: 1, z: 0, duration: 1000, baseAngle: 130, shoulderAngle: 0, elbowAngle: 0 },
            { x: -3, y: 1, z: -2.65, duration: 1000, baseAngle: 95, shoulderAngle: 0, elbowAngle: 0 },
            { x: -2, y: 1, z: -3.46, duration: 1000, baseAngle: 75, shoulderAngle: 0, elbowAngle: 0 },
            { x: -1, y: 1, z: -3.87, duration: 1200, baseAngle: 55, shoulderAngle: 0, elbowAngle: 0 },
            { x: 0, y: 1, z: -4, duration: 1200, baseAngle: 40, shoulderAngle: 0, elbowAngle: 0 },
            { x: 1, y: 1, z: -3.87, duration: 1000, baseAngle: 25, shoulderAngle: 0, elbowAngle: 0 },
            { x: 2, y: 1, z: -3.46, duration: 1000, baseAngle: 0, shoulderAngle: 0, elbowAngle: 0 },
            { x: 3, y: 1, z: -2.65, duration: 1000, baseAngle: -20.5, shoulderAngle: 0, elbowAngle: 0 },
            { x: 4, y: 1, z: 0, duration: 1200, baseAngle: -50, shoulderAngle: 0, elbowAngle: 0 }
        ];
        
        // FUNCI√ìN PARA CREAR PIEZA EN UNA L√çNEA ESPEC√çFICA
        function createPiece(lineId) {
            const line = productionLines[lineId];
            
            const material = new THREE.MeshStandardMaterial({ 
                color: line.color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: line.color,
                emissiveIntensity: 0.2
            });
            
            const piece = new THREE.Mesh(line.geometry.clone(), material);
            piece.position.set(-15, 1, line.zOffset);
            piece.castShadow = true;
            piece.receiveShadow = true;
            piece.visible = true;
            scene.add(piece);
            
            pieces[lineId].push({
                mesh: piece,
                state: 'onConveyor'
            });
            
            console.log(`${line.label} Nueva pieza en ${line.name}`);
        }
        
        function smoothAngle(current, target, speed) {
            const diff = target - current;
            if (Math.abs(diff) < 0.5) return target;
            return current + diff * speed;
        }
        
        // Control t√°ctil
        let touchStartX = 0, touchStartY = 0;
        let cameraRotationY = Math.PI / 4, cameraRotationX = 0;
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            cameraRotationY += deltaX * 0.005;
            cameraRotationX += deltaY * 0.005;
            
            cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        // Control de mouse
        let mouseDown = false;
        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - touchStartX;
            const deltaY = e.clientY - touchStartY;
            
            cameraRotationY += deltaX * 0.005;
            cameraRotationX += deltaY * 0.005;
            
            cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
            
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            
            // PROCESAR CADA L√çNEA DE PRODUCCI√ìN DE FORMA COMPLETAMENTE INDEPENDIENTE
            robots.forEach((robot, lineId) => {
                if (!robot.loaded) return;
                
                const line = productionLines[lineId];
                const linePieces = pieces[lineId];
                
                // Crear pieza si est√° permitido y no hay ninguna
                if (robot.canCreatePiece && linePieces.length === 0) {
                    createPiece(lineId);
                    robot.canCreatePiece = false;
                }
                
                // Mover piezas en banda
                linePieces.forEach(p => {
                    if (p.state === 'onConveyor') {
                        p.mesh.position.x += 0.035;
                        p.mesh.rotation.y += 0.02;
                    }
                });
                
                const timeInPhase = now - robot.phaseStartTime;
                
                // FASE 0: Posici√≥n inicial
                if (robot.animationPhase === 0) {
                    robot.targetBaseAngle = 0;
                    robot.targetShoulderAngle = 0;
                    robot.targetElbowAngle = 0;
                    
                    if (timeInPhase > 500) {
                        robot.animationPhase = 1;
                        robot.phaseStartTime = now;
                    }
                }
                
                // FASE 1: Aproximarse
                else if (robot.animationPhase === 1) {
                    robot.targetBaseAngle = 0;
                    robot.targetShoulderAngle = 130;
                    robot.targetElbowAngle = -50;
                    
                    if (timeInPhase > 2000) {
                        robot.animationPhase = 2;
                        robot.phaseStartTime = now;
                        robot.sequenceInitialized = false;
                    }
                }
                
                // FASE 2: Agarrar y mover
                else if (robot.animationPhase === 2) {
                    robot.targetBaseAngle = 0;
                    robot.targetShoulderAngle = 130;
                    robot.targetElbowAngle = 130;
                    
                    // Detectar colisi√≥n
                    if (!robot.pieceInGripper) {
                        for (let p of linePieces) {
                            if (p.state === 'onConveyor') {
                                const dx = p.mesh.position.x - 0;
                                const dz = p.mesh.position.z - line.zOffset;
                                const distance2D = Math.sqrt(dx * dx + dz * dz);
                                
                                if (distance2D < 4) {
                                    robot.pieceInGripper = p;
                                    robot.pieceInGripper.state = 'picked';
                                    robot.pieceInGripper.mesh.visible = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Inicializar secuencia
                    if (!robot.sequenceInitialized && robot.pieceInGripper) {
                        robot.currentMovementIndex = 0;
                        robot.movementStartTime = now;
                        robot.movementStartPos = {
                            x: robot.pieceInGripper.mesh.position.x,
                            y: robot.pieceInGripper.mesh.position.y,
                            z: robot.pieceInGripper.mesh.position.z
                        };
                        robot.sequenceInitialized = true;
                    }
                    
                    // Ejecutar movimientos
                    if (robot.pieceInGripper && robot.sequenceInitialized && robot.pieceInGripper.state === 'picked') {
                        const timeInMovement = now - robot.movementStartTime;
                        const currentMove = movementSequence[robot.currentMovementIndex];
                        
                        if (currentMove) {
                            const progress = Math.min(timeInMovement / currentMove.duration, 1);
                            const easeProgress = progress < 0.5 
                                ? 2 * progress * progress 
                                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                            
                            const newX = robot.movementStartPos.x + (currentMove.x - robot.movementStartPos.x) * easeProgress;
                            const newY = robot.movementStartPos.y + (currentMove.y - robot.movementStartPos.y) * easeProgress;
                            const newZ = robot.movementStartPos.z + ((currentMove.z + line.zOffset) - robot.movementStartPos.z) * easeProgress;
                            
                            robot.pieceInGripper.mesh.position.set(newX, newY, newZ);
                            robot.pieceInGripper.mesh.rotation.y += 0.02;
                            
                            robot.targetBaseAngle = currentMove.baseAngle;
                            robot.targetShoulderAngle = currentMove.shoulderAngle;
                            robot.targetElbowAngle = currentMove.elbowAngle;
                            
                            if (progress >= 1) {
                                robot.currentMovementIndex++;
                                if (robot.currentMovementIndex < movementSequence.length) {
                                    robot.movementStartTime = now;
                                    robot.movementStartPos = {
                                        x: robot.pieceInGripper.mesh.position.x,
                                        y: robot.pieceInGripper.mesh.position.y,
                                        z: robot.pieceInGripper.mesh.position.z
                                    };
                                } else {
                                    robot.animationPhase = 3;
                                    robot.phaseStartTime = now;
                                    robot.disappearTime = now + 1000;
                                }
                            }
                        }
                    }
                }
                
                // FASE 3: Desaparecer y reiniciar
                else if (robot.animationPhase === 3) {
                    robot.targetBaseAngle = 130;
                    robot.targetShoulderAngle = 0;
                    robot.targetElbowAngle = 0;
                    
                    if (now >= robot.disappearTime && robot.pieceInGripper) {
                        scene.remove(robot.pieceInGripper.mesh);
                        const index = linePieces.indexOf(robot.pieceInGripper);
                        if (index > -1) linePieces.splice(index, 1);
                        robot.pieceInGripper = null;
                        
                        robot.animationPhase = 0;
                        robot.phaseStartTime = now;
                        robot.canCreatePiece = true;
                    }
                }
                
                // Aplicar movimiento suave usando las variables PROPIAS del robot
                robot.baseAngle = smoothAngle(robot.baseAngle, robot.targetBaseAngle, 0.09);
                robot.shoulderAngle = smoothAngle(robot.shoulderAngle, robot.targetShoulderAngle, 0.09);
                robot.elbowAngle = smoothAngle(robot.elbowAngle, robot.targetElbowAngle, 0.09);
                
                // Aplicar rotaciones a las partes espec√≠ficas de ESTE robot
                if (robot.baseRotation && robot.baseRotation.rotation) {
                    robot.baseRotation.rotation.y = THREE.MathUtils.degToRad(robot.baseAngle);
                }
                if (robot.link1Group && robot.link1Group.rotation) {
                    robot.link1Group.rotation.z = THREE.MathUtils.degToRad(robot.shoulderAngle);
                }
                if (robot.link2Group && robot.link2Group.rotation) {
                    robot.link2Group.rotation.z = THREE.MathUtils.degToRad(robot.elbowAngle);
                }
                
                // Limpiar piezas que salen de la escena
                for (let i = linePieces.length - 1; i >= 0; i--) {
                    if (linePieces[i].mesh.position.x > 20 && linePieces[i].state === 'onConveyor') {
                        scene.remove(linePieces[i].mesh);
                        linePieces.splice(i, 1);
                    }
                }
            });
            
            // Animaci√≥n de luces
            inspectionStations.forEach(station => {
                station.indicators.forEach((ind, i) => {
                    ind.material.emissiveIntensity = 0.5 + Math.sin(now * 0.003 + i) * 0.4;
                });
            });
            
            // Actualizar c√°mara
            const radius = 28;
            const height = 18;
            
            camera.position.x = Math.sin(cameraRotationY) * radius;
            camera.position.z = Math.cos(cameraRotationY) * radius;
            camera.position.y = height + Math.sin(cameraRotationX) * 10;
            
            camera.lookAt(0, 3, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
