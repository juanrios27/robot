<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planta Automatizada - Brazo Rob√≥tico 3DOF</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Configuraci√≥n de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 30, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);
        camera.lookAt(0, 3, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Iluminaci√≥n
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(15, 20, 15);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 60;
        mainLight.shadow.camera.left = -30;
        mainLight.shadow.camera.right = 30;
        mainLight.shadow.camera.top = 30;
        mainLight.shadow.camera.bottom = -30;
        scene.add(mainLight);
        
        const fillLight = new THREE.PointLight(0x4a90e2, 0.8);
        fillLight.position.set(-10, 8, -10);
        scene.add(fillLight);
        
        const accentLight = new THREE.PointLight(0xff9500, 0.6);
        accentLight.position.set(10, 5, 10);
        scene.add(accentLight);
        
        // Piso
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a,
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grid
        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);
        
        // CONFIGURACI√ìN DEL MODELO GLB
        const ROBOT_CONFIG = {
            url: 'https://raw.githubusercontent.com/juanrios27/robot/main/Ensamble_Completo_de_dise%C3%B1o.glb',
            scale: 10,
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: -90, y: 0, z: 0 }
        };
        
        let robotGroup = new THREE.Group();
        let baseRotation, link1Group, link2Group, gripperBase;
        let robotLoaded = false;
        
        // Cargar modelo GLB
        function loadRobotGLB() {
            const loader = new THREE.GLTFLoader();
            
            console.log('üì¶ Cargando modelo GLB desde:', ROBOT_CONFIG.url);
            
            loader.load(
                ROBOT_CONFIG.url,
                function(gltf) {
                    console.log('‚úÖ Modelo GLB cargado exitosamente');
                    
                    const model = gltf.scene;
                    
                    model.scale.set(ROBOT_CONFIG.scale, ROBOT_CONFIG.scale, ROBOT_CONFIG.scale);
                    model.position.set(ROBOT_CONFIG.position.x, ROBOT_CONFIG.position.y, ROBOT_CONFIG.position.z);
                    model.rotation.set(
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.x),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.y),
                        THREE.MathUtils.degToRad(ROBOT_CONFIG.rotation.z)
                    );
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    robotGroup.add(model);
                    
                    baseRotation = model.getObjectByName('Base') || model.getObjectByName('base') || robotGroup;
                    link1Group = model.getObjectByName('Link1') || model.getObjectByName('Hombro') || robotGroup;
                    link2Group = model.getObjectByName('Link2') || model.getObjectByName('Codo') || robotGroup;
                    gripperBase = model.getObjectByName('Gripper') || model.getObjectByName('EndEffector') || robotGroup;
                    
                    scene.add(robotGroup);
                    robotLoaded = true;
                    
                    console.log('ü§ñ Robot integrado en la escena');
                },
                function(xhr) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    console.log('‚è≥ Cargando: ' + percent + '%');
                },
                function(error) {
                    console.error('‚ùå Error al cargar el modelo GLB:', error);
                }
            );
        }
        
        loadRobotGLB();
        
        // BANDA TRANSPORTADORA
        const conveyorGroup = new THREE.Group();
        
        const conveyorBase = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.6, 3.5),
            new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                roughness: 0.7,
                metalness: 0.3
            })
        );
        conveyorBase.position.y = 0.3;
        conveyorBase.castShadow = true;
        conveyorBase.receiveShadow = true;
        conveyorGroup.add(conveyorBase);
        
        const beltSurface = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.1, 3),
            new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.9
            })
        );
        beltSurface.position.y = 0.65;
        conveyorGroup.add(beltSurface);
        
        const edgeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.5 });
        
        const edge1 = new THREE.Mesh(
            new THREE.BoxGeometry(12, 0.5, 0.2),
            edgeMat
        );
        edge1.position.set(0, 0.65, 1.6);
        conveyorGroup.add(edge1);
        
        const edge2 = edge1.clone();
        edge2.position.z = -1.6;
        conveyorGroup.add(edge2);
        
        conveyorGroup.position.set(-9, 0, 0);
        scene.add(conveyorGroup);
        
        // ESTACI√ìN DE INSPECCI√ìN
        const inspectionStation = new THREE.Group();
        
        const stationBase = new THREE.Mesh(
            new THREE.BoxGeometry(3.5, 1.8, 3.5),
            new THREE.MeshStandardMaterial({ 
                color: 0x27ae60,
                roughness: 0.5,
                metalness: 0.4,
                emissive: 0x27ae60,
                emissiveIntensity: 0.1
            })
        );
        stationBase.position.y = 0.9;
        stationBase.castShadow = true;
        inspectionStation.add(stationBase);
        
        const stationPanel = new THREE.Mesh(
            new THREE.BoxGeometry(3, 2.5, 0.2),
            new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.2,
                metalness: 0.8
            })
        );
        stationPanel.position.set(0, 2.5, 1.8);
        inspectionStation.add(stationPanel);
        
        const indicators = [];
        for (let i = 0; i < 3; i++) {
            const indicator = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 2, 32),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.8
                })
            );
            indicator.position.set(-0.8 + i * 0.8, 2.8, 1.5);
            inspectionStation.add(indicator);
            indicators.push(indicator);
            
            const light = new THREE.PointLight(0x00ffff, 0.5, 6);
            light.position.copy(indicator.position);
            inspectionStation.add(light);
        }
        
        inspectionStation.position.set(8, 0, 0);
        scene.add(inspectionStation);
        
        // SISTEMA DE PIEZAS
        const pieces = [];
        const pieceMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff9500,
            roughness: 0.4,
            metalness: 0.6,
            emissive: 0xff9500,
            emissiveIntensity: 0.2
        });
        
        function createPiece() {
            const piece = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                pieceMaterial
            );
            piece.position.set(-15, 1, 0);
            piece.castShadow = true;
            piece.receiveShadow = true;
            piece.visible = true;
            scene.add(piece);
            pieces.push({
                mesh: piece,
                state: 'onConveyor'
            });
            console.log('üì¶ Nueva caja creada');
        }
        
        // SECUENCIA DE MOVIMIENTOS PREDEFINIDOS
        const movementSequence = [
            { x: -4, y: 1, z:0 , duration: 1000, baseAngle: 130, shoulderAngle: 0, elbowAngle: 0 },
            { x: -3, y: 1, z: -2.65, duration: 1000, baseAngle: 100, shoulderAngle: 0, elbowAngle: 0 },
            { x: -2, y: 1, z: -3.46, duration: 1000, baseAngle: 80, shoulderAngle: 0, elbowAngle: 0 },
            { x: -1, y: 1, z: -3.87, duration: 1200, baseAngle: 55, shoulderAngle: 0, elbowAngle: 0 },
            { x: 0, y: 1, z: -4, duration: 1200, baseAngle: 40, shoulderAngle: 0, elbowAngle: 0 },
            { x: 1, y: 1, z:-3.87 , duration: 1000, baseAngle: 17.5, shoulderAngle: 0, elbowAngle: 0 },
            { x: 2, y: 1, z: -3.46, duration: 1000, baseAngle: -5, shoulderAngle: 0, elbowAngle: 0 },
            { x: 3, y: 1, z: -2.65, duration: 1000, baseAngle: -27.5, shoulderAngle: 0, elbowAngle: 0 },
            { x: 4, y: 1, z: 0, duration: 1200, baseAngle: -50, shoulderAngle: 0, elbowAngle: 0 }
            
        ];
        
        // Variables de animaci√≥n
        let baseAngle = 0;
        let shoulderAngle = 0;
        let elbowAngle = 0;
        
        let pieceInGripper = null;
        let animationPhase = 0;
        let phaseStartTime = Date.now();
        
        // Variables para la secuencia de movimientos
        let currentMovementIndex = 0;
        let movementStartTime = 0;
        let movementStartPos = { x: 0, y: 0, z: 0 };
        let sequenceInitialized = false;
        
        // Variable para controlar la desaparici√≥n
        let disappearTime = 0;
        
        let canCreatePiece = true;
        
        function smoothAngle(current, target, speed) {
            const diff = target - current;
            if (Math.abs(diff) < 0.5) return target;
            return current + diff * speed;
        }
        
        // Control de orientaci√≥n del dispositivo
        let alpha = 0, beta = 0, gamma = 0;
        
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function(event) {
                alpha = event.alpha || 0;
                beta = event.beta || 0;
                gamma = event.gamma || 0;
            });
        }
        
        // Control t√°ctil
        let touchStartX = 0, touchStartY = 0;
        let cameraRotationY = 0, cameraRotationX = 0;
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            cameraRotationY += deltaX * 0.005;
            cameraRotationX += deltaY * 0.005;
            
            cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            
            // Crear pieza solo si est√° permitido y no hay ninguna
            if (canCreatePiece && pieces.length === 0) {
                createPiece();
                canCreatePiece = false;
            }
            
            // Mover piezas en banda SOLO si no est√°n siendo agarradas
            pieces.forEach(p => {
                if (p.state === 'onConveyor') {
                    p.mesh.position.x += 0.035;
                    p.mesh.rotation.y += 0.02;
                }
            });
            
            // Definir targets seg√∫n fase
            let targetBase = 0, targetShoulder = 0, targetElbow = 0;
            
            const timeInPhase = now - phaseStartTime;
            
            // FASE 0: Posici√≥n inicial
            if (animationPhase === 0) {
                targetBase = 0;
                targetShoulder = 0;
                targetElbow = 0;
                
                if (timeInPhase > 500) {
                    animationPhase = 1;
                    phaseStartTime = now;
                    console.log('üîÑ FASE 1: Aproximarse a la caja');
                }
            }
            
            // FASE 1: Aproximarse y agarrar
            else if (animationPhase === 1) {
                targetBase = -50;
                targetShoulder = 0;
                targetElbow = 0;
                
                if (timeInPhase > 2000) {
                    animationPhase = 2;
                    phaseStartTime = now;
                    sequenceInitialized = false;
                    console.log('üîÑ FASE 2: Posicionarse para recibir la caja');
                }
            }
            
            // FASE 2: Posicionarse y detectar caja, luego secuencia de movimientos
            else if (animationPhase === 2) {
                targetBase = 130;
                targetShoulder = 0;
                targetElbow = 0;
                
                // Detectar colisi√≥n en fase 2 cuando el robot est√° posicionado
                if (!pieceInGripper) {
                    for (let p of pieces) {
                        if (p.state === 'onConveyor') {
                            // Calcular distancia simple en el plano XZ
                            const dx = p.mesh.position.x - 0; // Robot est√° en x=0
                            const dz = p.mesh.position.z - 0; // Robot est√° en z=0
                            const distance2D = Math.sqrt(dx * dx + dz * dz);
                            
                            console.log(`üìè Distancia 2D caja-robot: ${distance2D.toFixed(2)} | Pos caja: (${p.mesh.position.x.toFixed(1)}, ${p.mesh.position.y.toFixed(1)}, ${p.mesh.position.z.toFixed(1)})`);
                            
                            // Agarrar cuando est√° cerca del robot
                            if (distance2D < 4) {
                                pieceInGripper = p;
                                pieceInGripper.state = 'picked';
                                pieceInGripper.mesh.visible = true;
                                console.log('‚úÖ Caja agarrada! Estado:', pieceInGripper.state);
                                break;
                            }
                        }
                    }
                }
                
                // Inicializar secuencia
                if (!sequenceInitialized && pieceInGripper) {
                    currentMovementIndex = 0;
                    movementStartTime = now;
                    movementStartPos = {
                        x: pieceInGripper.mesh.position.x,
                        y: pieceInGripper.mesh.position.y,
                        z: pieceInGripper.mesh.position.z
                    };
                    sequenceInitialized = true;
                    console.log('üéØ Secuencia iniciada desde posici√≥n:', movementStartPos);
                    console.log('üéØ Caja en gripper existe:', !!pieceInGripper);
                }
                
                // Ejecutar movimientos - MOVER CAJA Y BRAZO JUNTOS
                if (pieceInGripper && sequenceInitialized && pieceInGripper.state === 'picked') {
                    const timeInMovement = now - movementStartTime;
                    const currentMove = movementSequence[currentMovementIndex];
                    
                    if (currentMove) {
                        const progress = Math.min(timeInMovement / currentMove.duration, 1);
                        
                        // Interpolaci√≥n suave
                        const easeProgress = progress < 0.5 
                            ? 2 * progress * progress 
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        const newX = movementStartPos.x + (currentMove.x - movementStartPos.x) * easeProgress;
                        const newY = movementStartPos.y + (currentMove.y - movementStartPos.y) * easeProgress;
                        const newZ = movementStartPos.z + (currentMove.z - movementStartPos.z) * easeProgress;
                        
                        // Mover la caja
                        pieceInGripper.mesh.position.set(newX, newY, newZ);
                        pieceInGripper.mesh.rotation.y += 0.02;
                        
                        // DEFINIR √ÅNGULOS DEL BRAZO seg√∫n el movimiento actual
                        targetBase = currentMove.baseAngle;
                        targetShoulder = currentMove.shoulderAngle;
                        targetElbow = currentMove.elbowAngle;
                        
                        console.log(`üìç Punto ${currentMovementIndex + 1}/4 - ${(progress * 100).toFixed(0)}% - Pos: (${newX.toFixed(1)}, ${newY.toFixed(1)}, ${newZ.toFixed(1)}) - √Ångulos: Base=${targetBase}¬∞ Hombro=${targetShoulder}¬∞ Codo=${targetElbow}¬∞`);
                        
                        // Pasar al siguiente punto
                        if (progress >= 1) {
                            currentMovementIndex++;
                            if (currentMovementIndex < movementSequence.length) {
                                movementStartTime = now;
                                movementStartPos = {
                                    x: pieceInGripper.mesh.position.x,
                                    y: pieceInGripper.mesh.position.y,
                                    z: pieceInGripper.mesh.position.z
                                };
                                console.log(`‚úÖ Punto ${currentMovementIndex} completado, siguiente...`);
                            } else {
                                console.log('‚úÖ Secuencia completa! Pasando a fase 3');
                                animationPhase = 3;
                                phaseStartTime = now;
                                disappearTime = now + 1000;
                            }
                        }
                    } else {
                        console.log('‚ùå currentMove no existe');
                    }
                } else {
                    if (!pieceInGripper) console.log('‚ùå No hay pieza en gripper');
                    if (!sequenceInitialized) console.log('‚ùå Secuencia no inicializada');
                }
            }
            
            // FASE 3: Quedarse quieta y desaparecer
            else if (animationPhase === 3) {
                targetBase = 130;
                targetShoulder = 0;
                targetElbow = 0;
                
                // La caja ya est√° quieta, solo esperar
                if (now >= disappearTime && pieceInGripper) {
                    console.log('üí® Caja desapareciendo...');
                    scene.remove(pieceInGripper.mesh);
                    const index = pieces.indexOf(pieceInGripper);
                    if (index > -1) pieces.splice(index, 1);
                    pieceInGripper = null;
                    
                    // Reiniciar ciclo
                    animationPhase = 0;
                    phaseStartTime = now;
                    canCreatePiece = true;
                    console.log('üîÑ Ciclo reiniciado, esperando nueva caja...');
                }
            }
            
            // Aplicar movimiento suave al robot
            baseAngle = smoothAngle(baseAngle, targetBase, 0.09);
            shoulderAngle = smoothAngle(shoulderAngle, targetShoulder, 0.09);
            elbowAngle = smoothAngle(elbowAngle, targetElbow, 0.09);
            
            if (baseRotation && baseRotation.rotation) {
                baseRotation.rotation.y = THREE.MathUtils.degToRad(baseAngle);
            }
            if (link1Group && link1Group.rotation) {
                link1Group.rotation.z = THREE.MathUtils.degToRad(shoulderAngle);
            }
            if (link2Group && link2Group.rotation) {
                link2Group.rotation.z = THREE.MathUtils.degToRad(elbowAngle);
            }
            
            // La caja sigue al gripper en fase 1 (ya lo hace dentro del if de fase 1)
            
            // Limpiar piezas que salen de la escena
            for (let i = pieces.length - 1; i >= 0; i--) {
                if (pieces[i].mesh.position.x > 20 && pieces[i].state === 'onConveyor') {
                    scene.remove(pieces[i].mesh);
                    pieces.splice(i, 1);
                }
            }
            
            // Animaci√≥n de luces
            indicators.forEach((ind, i) => {
                ind.material.emissiveIntensity = 0.5 + Math.sin(now * 0.003 + i) * 0.4;
            });
            
            // Actualizar c√°mara
            const radius = 16;
            const height = 10;
            
            if (alpha !== 0 || beta !== 0 || gamma !== 0) {
                const angleY = THREE.MathUtils.degToRad(alpha);
                const angleX = THREE.MathUtils.degToRad(beta - 90) * 0.3;
                
                camera.position.x = Math.sin(angleY) * radius;
                camera.position.z = Math.cos(angleY) * radius;
                camera.position.y = height + angleX * 5;
            } else {
                camera.position.x = Math.sin(cameraRotationY) * radius;
                camera.position.z = Math.cos(cameraRotationY) * radius;
                camera.position.y = height + Math.sin(cameraRotationX) * 8;
            }
            
            camera.lookAt(0, 3, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
